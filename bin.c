/***********************************************************************************************************************************************************************************************************************************
 * \file bin.c
 * \brief Library for handling binary words
 * \author dark.anonymous.fr@gmail.com
 * \version 0.1
 * \date 12/04/2016
 **********************************************************************************************************************************************************************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <time.h>
#include <limits.h>
#include <math.h>

#include "ptrop.h"
#include "logger.h"
#include "str.h"
#include "file.h"
#include "bin.h"

/** ********************************************************************************************************************************************************************************************************************************
 * \fn unsigned short binw_set_sz()
 **********************************************************************************************************************************************************************************************************************************
 * \brief Initializes the global variable BINW_SZ
 **********************************************************************************************************************************************************************************************************************************
 * \return  X[t_uint64] &rarr; The number of bits set to define the binary words
 *
 * This is the first function to call before using any others because it will initialize the global variable BINW_SZ which represents the number of bits of a binary word. \n
 * The size of X can be modified according to what you need.
 *********************************************************************************************************************************************************************************************************************************/
unsigned short binw_set_sz()
{
    srand(time(NULL));
    t_uint64 X = sizeof(long long int);
    BINW_SZ = 8*X;
    fprintf(logger, "bin.c::binw_set_sz -> The binary word size is %d Byte(s) long \n",sizeof(long long int));
    return X;
}

/** ********************************************************************************************************************************************************************************************************************************
 * \fn void binw_destroy(t_binw *p)
 **********************************************************************************************************************************************************************************************************************************
 * \brief Destroys a binary word
 **********************************************************************************************************************************************************************************************************************************
 * \return  p[t_binw*] &rarr; Pointer to the binary word.
 *
 *********************************************************************************************************************************************************************************************************************************/
void binw_destroy(t_binw *p)
{
    if (p) //T0
        free(p), p=NULL;

    else fprintf(logger, "bin.c::binw_destroy.T0 -> p is NULL\n");
}

/** ********************************************************************************************************************************************************************************************************************************
 * \fn t_binw *binw_create()
 **********************************************************************************************************************************************************************************************************************************
 * \brief Creates a binary word
 **********************************************************************************************************************************************************************************************************************************
 * \return  p[t_binw*] &rarr; Pointer to the binary word.
 *
 * It creates a binary word of BINW_SZ bits. \n
 * Each bit of the binary word is initialized to zero. \n
 * The LSB index is defined at position zero. \n
 * The MSB index is defined at position BINW_SZ-1. \n
 * If the allocation of the pointer has failed then it will returns NULL.
 *********************************************************************************************************************************************************************************************************************************/
t_binw *binw_create()
{
    t_uint64 i;
    t_binw *p=NULL;
    if ( (p=(t_binw*)malloc(BINW_SZ*sizeof(t_bit))) ) //T0
        for(i=0 ; i<BINW_SZ ; i++)
            p[i]=0;

    else fprintf(logger, "bin.c::binw_create.T0 -> %s\n", strerror(errno));
    return p;
}

/** ********************************************************************************************************************************************************************************************************************************
 * \fn t_binw *binw_create_dyn(t_uint64 x)
 **********************************************************************************************************************************************************************************************************************************
 * \brief Creates a binary word of x bits
 **********************************************************************************************************************************************************************************************************************************
 * \param   x[t_uint64] &rarr; Size of the binary word
 * \return  p[t_binw*] &rarr; Pointer to the binary word
 *
 * Each bit of the binary word is initialized with zero. \n
 * The LSB index is defined at position zero. \n
 * The MSB index in defined at position x-1. \n
 * If the allocation of the pointer has failed then it will returns NULL.
 *********************************************************************************************************************************************************************************************************************************/
t_binw *binw_create_dyn(t_uint64 x)
{
    t_uint64 i;
    t_bit *p=NULL;
    if ( (p=(t_binw*)malloc(x*sizeof(t_bit))) ) //T0
        for(i=0 ; i<x ; i++)
            p[i]=0;

    else fprintf(logger, "bin.c::binw_create.T0 -> %s\n", strerror(errno));
    return p;
}

/** ********************************************************************************************************************************************************************************************************************************
 * \fn void binw_display(t_binw *p, const char *title)
 **********************************************************************************************************************************************************************************************************************************
 * \brief Displays a binary word
 **********************************************************************************************************************************************************************************************************************************
 * \param       p[t_binw*]     &rarr; Pointer to the binary word
 * \param   title[const char*] &rarr; Title for the binary word
 *
 * The binary word must size exactly the BINW_SZ value
 *********************************************************************************************************************************************************************************************************************************/
void binw_display(t_binw *p, const char *title)
{
    if (p) //T0
    {
        printf("\n");
        t_uint64 i=0;
        if(title)
            printf("%s : ",title);
        for(i=BINW_SZ-1 ; i>0 ; i--)
        {
            printf("%d", p[i]);
            if ( (i-4)%8==0 && i!=(t_uint64)BINW_SZ-1 )
                printf("-");

            if (i%8==0 && i!=(t_uint64)BINW_SZ-1 )
                 printf(" ");
        }
        printf("%d", p[i]);
    }
    else fprintf(logger, "bin.c::binw_display.T0 -> p is NULL\n");
}

/** ********************************************************************************************************************************************************************************************************************************
 * \fn void binw_display_dyn(t_binw *p, t_uint64 l, const char *title)
 **********************************************************************************************************************************************************************************************************************************
 * \brief Displays a binary word of a specified size
 **********************************************************************************************************************************************************************************************************************************
 * \param       p[t_binw*]     &rarr; Pointer to the binary word
 * \param       l[t_uint64]     &rarr; Number of bits to display from LSB
 * \param   title[const char*] &rarr; Title for the binary word
 *
 * The binary word must size at least the l value \n
 * You can assign a name to the binary word if you have several of them to display
 *********************************************************************************************************************************************************************************************************************************/
void binw_display_dyn(t_binw *p, t_uint64 l, const char *title)
{
    if (p) //T0
    {
        printf("\n");
        t_uint64 i;
        if(title)
            printf("%s : ",title);

        for(i=l-1 ; i>0 ; i--)
            printf("%d", p[i]);

        printf("%d", p[i]);
    }
    else fprintf(logger, "bin.c::binw_display_dyn.T0 -> p is NULL\n");
}

/** ********************************************************************************************************************************************************************************************************************************
 * \fn t_bit bit_not( t_bit b )
 **********************************************************************************************************************************************************************************************************************************
 * \brief Operate a OR b
 **********************************************************************************************************************************************************************************************************************************
 * \param   a[t_bit] &rarr; A bit b
 * \return  s[t_bit] &rarr; A bit s = NOT(b)
 *
 * You should test the return of bit_not.
 * If it returns 2 then or b might have an inapropriate value
 *
 *********************************************************************************************************************************************************************************************************************************/
t_bit bit_not( t_bit b )
{
    t_bit s=2;

         if ( b==0 ) {s=1;}
    else if ( b==1 ) {s=0;}
    else
    {
        if ( b!=1 && b!=0 )
            fprintf(logger, "bin.c::bit_not -> b = %d", b);
    }
    return s;
}

/** ********************************************************************************************************************************************************************************************************************************
 * \fn t_bit bit_or( t_bit a, t_bit b )
 **********************************************************************************************************************************************************************************************************************************
 * \brief Operate a OR b
 **********************************************************************************************************************************************************************************************************************************
 * \param   a[t_bit] &rarr; A bit a
 * \param   b[t_bit] &rarr; A bit b
 * \return  s[t_bit] &rarr; A bit s = a OR b
 *
 * You should test the return of bit_or.
 * If it returns 2 then a and or b might have inapropriate values
 *
 ** *******************************************************************************************************************************************************************************************************************************/
t_bit bit_or( t_bit a, t_bit b )
{
    t_bit s=2;

         if ( (a==1 && b==0) || (a==0 && b==1) || (a==1 && b==1) ) {s=1;}
    else if ( (a==0 && b==0)                                     ) {s=0;}
    else
    {
        if ( a!=1 && a!=0 )
            fprintf(logger, "bin.c::bit_or -> a = %d", a);

        if ( b!=1 && b!=0 )
            fprintf(logger, "bin.c::bit_or -> b = %d", b);
    }
    return s;
}

/** ********************************************************************************************************************************************************************************************************************************
 * \fn t_bit bit_nor( t_bit a, t_bit b )
 **********************************************************************************************************************************************************************************************************************************
 * \brief Operate a NOR b
 **********************************************************************************************************************************************************************************************************************************
 * \param   a[t_bit] &rarr; A bit a
 * \param   b[t_bit] &rarr; A bit b
 * \return  s[t_bit] &rarr; A bit s = a NOR b
 *
 * You should test the return of bit_nor.
 * If it returns 2 then a and or b might have inapropriate values
 *
 *********************************************************************************************************************************************************************************************************************************/
t_bit bit_nor( t_bit a, t_bit b )
{
    t_bit s=2;

         if ( (a==1 && b==0) || (a==0 && b==1) || (a==1 && b==1) ) {s=1;}
    else if ( (a==0 && b==0)                                     ) {s=0;}
    else
    {
        if ( a!=1 && a!=0 )
            fprintf(logger, "bin.c::bit_nor -> a = %d", a);

        if ( b!=1 && b!=0 )
            fprintf(logger, "bin.c::bit_nor -> b = %d", b);
    }
    return bit_not(s);
}

/** ********************************************************************************************************************************************************************************************************************************
 * \fn t_bit bit_and( t_bit a, t_bit b )
 **********************************************************************************************************************************************************************************************************************************
 * \brief Operate a AND b
 **********************************************************************************************************************************************************************************************************************************
 * \param   a[t_bit] &rarr; A bit a
 * \param   b[t_bit] &rarr; A bit b
 * \return  s[t_bit] &rarr; A bit s = a AND b
 *
 * You should test the return of bit_and.
 * If it returns 2 then a and/or b might have inapropriate values
 *
 *********************************************************************************************************************************************************************************************************************************/
t_bit bit_and( t_bit a, t_bit b )
{
    t_bit s=2;

         if ( (a==1 && b==0) || (a==0 && b==1) || (a==0 && b==0) ) {s=0;}
    else if ( (a==1 && b==1)                                     ) {s=1;}
    else
    {
        if ( a!=1 && a!=0 )
            fprintf(logger, "bin.c::bit_and -> a = %d", a);

        if ( b!=1 && b!=0 )
            fprintf(logger, "bin.c::bit_and -> b = %d", b);
    }
    return s;
}

/** ********************************************************************************************************************************************************************************************************************************
 * \fn t_bit bit_nand( t_bit a, t_bit b )
 **********************************************************************************************************************************************************************************************************************************
 * \brief Operate a AND b
 **********************************************************************************************************************************************************************************************************************************
 * \param   a[t_bit] &rarr; A bit a
 * \param   b[t_bit] &rarr; A bit b
 * \return  s[t_bit] &rarr; A bit s = a NAND b
 *
 * You should test the return of bit_nand.
 * If it returns 2 then a and/or b might have inapropriate values
 *
 *********************************************************************************************************************************************************************************************************************************/
t_bit bit_nand( t_bit a, t_bit b )
{
    t_bit s=2;

         if ( (a==1 && b==0) || (a==0 && b==1) || (a==0 && b==0) ) {s=0;}
    else if ( (a==1 && b==1)                                     ) {s=1;}
    else
    {
        if ( a!=1 && a!=0 )
            fprintf(logger, "bin.c::bit_nand -> a = %d", a);

        if ( b!=1 && b!=0 )
            fprintf(logger, "bin.c::bit_nand -> b = %d", b);
    }
    return bit_not(s);
}

/** ********************************************************************************************************************************************************************************************************************************
 * \fn t_bit bit_xor( t_bit a, t_bit b )
 **********************************************************************************************************************************************************************************************************************************
 * \brief Operate a XOR b
 **********************************************************************************************************************************************************************************************************************************
 * \param   a[t_bit] &rarr; A bit a
 * \param   b[t_bit] &rarr; A bit b
 * \return  s[t_bit] &rarr; A bit s = a XOR b
 *
 * You should test the return of bit_xor.
 * If it returns 2 then a and/or b might have inapropriate values
 *
 *********************************************************************************************************************************************************************************************************************************/
t_bit bit_xor( t_bit a, t_bit b )
{
    t_bit s=2;

         if ( (a==1 && b==0) || (a==0 && b==1) ) {s=1;}
    else if ( (a==1 && b==1) || (a==0 && b==0) ) {s=0;}
    else
    {
        if ( a!=1 && a!=0 )
            fprintf(logger, "bin.c::bit_xor -> a = %d", a);

        if ( b!=1 && b!=0 )
            fprintf(logger, "bin.c::bit_xor -> b = %d", b);
    }
    return s;
}

/** ********************************************************************************************************************************************************************************************************************************
 * \fn t_bit bit_xnor( t_bit a, t_bit b )
 **********************************************************************************************************************************************************************************************************************************
 * \brief Operate a XNOR b
 **********************************************************************************************************************************************************************************************************************************
 * \param   a[t_bit] &rarr; A bit a
 * \param   b[t_bit] &rarr; A bit b
 * \return  s[t_bit] &rarr; A bit s = a XNOR b
 *
 * You should test the return of bit_xnor.
 * If it returns 2 then a and/or b might have inapropriate values
 *
 *********************************************************************************************************************************************************************************************************************************/
t_bit bit_xnor( t_bit a, t_bit b )
{
    t_bit s=2;

         if ( (a==1 && b==0) || (a==0 && b==1) ) {s=1;}
    else if ( (a==1 && b==1) || (a==0 && b==0) ) {s=0;}
    else
    {
        if ( a!=1 && a!=0 )
            fprintf(logger, "bin.c::bit_xnor -> a = %d", a);

        if ( b!=1 && b!=0 )
            fprintf(logger, "bin.c::bit_xnor -> b = %d", b);
    }
    return s;
}

/** ********************************************************************************************************************************************************************************************************************************
 * \fn t_binw *binw_or( t_binw *a, t_binw *b )
 **********************************************************************************************************************************************************************************************************************************
 * \brief Operate a OR b
 **********************************************************************************************************************************************************************************************************************************
 * \param   a[t_binw *] &rarr; A binary word a
 * \param   b[t_binw *] &rarr; A binary word b
 * \return  s[t_binw *] &rarr; 1 binary word s = a OR b
 *
 **********************************************************************************************************************************************************************************************************************************/
t_binw *binw_or( t_binw *a, t_binw *b )
{
    t_binw *b_out = NULL;
    if ( a && b ) //T0
    {
        if ( (b_out = binw_create()) ) //T1
        {
            t_uint64 i;
            for ( i=0 ; i<(t_uint64)BINW_SZ ; i++  )
                b_out[i]=bit_or( a[i], b[i] );
        }
        else fprintf(logger,"bin.c::binw_or.T1 -> binw_create returned NULL");

    }
    else
    {
        if (!a)
            fprintf(logger,"bin.c::binw_or.T0 -> a is NULL");
        if (!b)
            fprintf(logger,"bin.c::binw_or.T0 -> b is NULL");
    }
    return b_out;
}

/** ********************************************************************************************************************************************************************************************************************************
 * \fn t_binw *binw_nor( t_binw *a, t_binw *b )
 **********************************************************************************************************************************************************************************************************************************
 * \brief Operate a NOR b
 *
 * \param   a[t_binw *] &rarr; A binary word a
 * \param   b[t_binw *] &rarr; A binary word b
 * \return  s[t_binw *] &rarr; 1 binary word s = a NOR b
 *
 *********************************************************************************************************************************************************************************************************************************/
t_binw *binw_nor( t_binw *a, t_binw *b )
{
    t_binw *b_out = NULL;
    if ( a && b ) //T0
    {
        if ( (b_out = binw_create()) ) //T1
        {
            t_uint64 i;
            for ( i=0 ; i<(t_uint64)BINW_SZ ; i++  )
                b_out[i]=bit_nor( a[i], b[i] );
        }
        else fprintf(logger,"bin.c::binw_nor.T1 -> binw_create returned NULL");
    }
    else
    {
        if (!a)
            fprintf(logger,"bin.c::binw_nor.T0 -> a is NULL");
        if (!b)
            fprintf(logger,"bin.c::binw_nor.T0 -> b is NULL");
    }
    return b_out;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_binw *binw_and( t_binw *a, t_binw *b )
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Operate a AND b
 ***********************************************************************************************************************************************************************************************************************************
 * \param   a[t_binw *] &rarr; A binary word a
 * \param   b[t_binw *] &rarr; A binary word b
 * \return  s[t_binw *] &rarr; 1 binary word s = a AND b
 *
 **********************************************************************************************************************************************************************************************************************************/
t_binw *binw_and( t_binw *a, t_binw *b )
{
    t_binw *b_out = NULL;
    if ( a && b ) //T0
    {
        if ( (b_out = binw_create()) ) //T1
        {
            t_uint64 i;
            for ( i=0 ; i<(t_uint64)BINW_SZ ; i++  )
                b_out[i]=bit_and( a[i], b[i] );
        }
        else fprintf(logger,"bin.c::binw_and.T1 -> binw_create returned NULL");

    }
    else
    {
        if (!a)
            fprintf(logger,"bin.c::binw_and.T0 -> a is NULL");
        if (!b)
            fprintf(logger,"bin.c::binw_and.T0 -> b is NULL");
    }
    return b_out;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_binw *binw_nand( t_binw *a, t_binw *b )
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Operate a NOR b
 ***********************************************************************************************************************************************************************************************************************************
 * \param   a[t_binw *] &rarr; A binary a
 * \param   b[t_binw *] &rarr; A binary word b
 * \return  s[t_binw *] &rarr; 1 binary word s = a NAND b
 *
 **********************************************************************************************************************************************************************************************************************************/
t_binw *binw_nand( t_binw *a, t_binw *b )
{
    t_binw *b_out = NULL;
    if ( a && b ) //T0
    {
        if ( (b_out = binw_create()) ) //T1
        {
            t_uint64 i;
            for ( i=0 ; i<(t_uint64)BINW_SZ ; i++  )
                b_out[i]=bit_nand( a[i], b[i] );
        }
        else fprintf(logger,"bin.c::binw_nand.T1 -> binw_create returned NULL");
    }
    else
    {
        if (!a)
            fprintf(logger,"bin.c::binw_nand.T0 -> a is NULL");
        if (!b)
            fprintf(logger,"bin.c::binw_nand.T0 -> b is NULL");
    }
    return b_out;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_binw *binw_xor( t_binw *a, t_binw *b )
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Operate a NOR b
 ***********************************************************************************************************************************************************************************************************************************
 * \param   a[t_binw *] &rarr; A binary word a
 * \param   b[t_binw *] &rarr; A binary word b
 * \return  s[t_binw *] &rarr; 1 binary word s = a XOR b
 *
 **********************************************************************************************************************************************************************************************************************************/
t_binw *binw_xor( t_binw *a, t_binw *b )
{
    t_binw *b_out = NULL;
    if ( a && b ) //T0
    {
        if ( (b_out = binw_create()) ) //T1
        {
            t_uint64 i;
            for ( i=0 ; i<(t_uint64)BINW_SZ ; i++  )
                b_out[i]=bit_xor( a[i], b[i] );
        }
        else fprintf(logger,"bin.c::binw_xor.T1 -> binw_create returned NULL");
    }
    else
    {
        if (!a)
            fprintf(logger,"bin.c::binw_xor.T0 -> a is NULL");
        if (!b)
            fprintf(logger,"bin.c::binw_xor.T0 -> b is NULL");
    }
    return b_out;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_binw *binw_xnor( t_binw *a, t_binw *b )
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Operate a XNOR b
 ***********************************************************************************************************************************************************************************************************************************
 * \param   a[t_binw *] &rarr; A binary word a
 * \param   b[t_binw *] &rarr; A binary word b
 * \return  s[t_binw *] &rarr; 1 binary word s = a XNOR b
 *
 **********************************************************************************************************************************************************************************************************************************/
t_binw *binw_xnor( t_binw *a, t_binw *b )
{
    t_binw *b_out = NULL;
    if ( a && b ) //T0
    {
        if ( (b_out = binw_create()) ) //T1
        {
            t_uint64 i;
            for ( i=0 ; i<(t_uint64)BINW_SZ ; i++  )
                b_out[i]=bit_xnor( a[i], b[i] );
        }
        else fprintf(logger,"bin.c::binw_xnor.T1 -> binw_create returned NULL");
    }
    else
    {
        if (!a)
            fprintf(logger,"bin.c::binw_xnor.T0 -> a is NULL");
        if (!b)
            fprintf(logger,"bin.c::binw_xnor.T0 -> b is NULL");
    }
    return b_out;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_binw *binw_create_random()
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Creates a random binary word of the BINW_SZ value size
 ***********************************************************************************************************************************************************************************************************************************
 * \return  p[t_binw*] &rarr; Pointer to the binary word
 *
 **********************************************************************************************************************************************************************************************************************************/
t_binw *binw_create_random()
{
    t_uint64 i;
    t_bit *p=NULL;
    if ( (p=binw_create()) ) //T0
        for(i=0 ; i<BINW_SZ ; i++)
            p[i]=rand()%2;

    else fprintf(logger, "bin.c::binw_create_random.T0 -> p is NULL\n");
    return p;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_bit binw_check_sign(t_binw *a)
 * \brief Checks the sign of a binary word
 *
 * \return  sign[t_bit] &rarr; The sign of the binary word
 *
 * If the function returns \n
 *   -0 &rArr; The binary word is positive \n
 *   -1 &rArr; The binary word is negative \n
 *   -2 &rArr; An error occurred. The binary word was probably not allocated properly
 **********************************************************************************************************************************************************************************************************************************/
t_bit binw_check_sign(t_binw *a)
{
    t_bit sign=2;
    if (a)
        sign=a[BINW_SZ-1];

    else fprintf(logger, "bin.c::binw_check_sign -> a is NULL\n");
    return sign;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_binw *binw_fill_zero( t_binw *b_in, t_uint64 offset )
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Fills specified bits of a binary word with zeros.
 ***********************************************************************************************************************************************************************************************************************************
 * \param     b_in[t_binw*] &rarr; The binary word to fill with zeros
 * \param   offset[t_uint64] &rarr; The position of the last bit to become a zero
 *
 * The function will fill the binary word with zeros from the least significant bit to the offset value
 **********************************************************************************************************************************************************************************************************************************/
t_binw *binw_fill_zero( t_binw *b_in, t_uint64 offset )
{
    t_bit *b_out = NULL;
    if (b_in) //T0
    {
        if ( (b_out=binw_create()) ) //T1
        {
            t_uint64 i;
            for (i=0 ; i<BINW_SZ ; i++)
            {
                if (i<offset)
                    b_out[i]=b_in[i];

                else b_out[i]=0;
            }
        }
        else fprintf(logger, "bin.c::binw_fill_zero.T1 -> b_out is NULL\n");
    }
    else fprintf(logger, "bin.c::binw_fill_zero.T0 -> b_in is NULL");
    return b_out;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_binw *binw_fill_one( t_binw *b_in, t_uint64 offset )
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Fills specified bits of a binary word with zeros.
 ***********************************************************************************************************************************************************************************************************************************
 * \param    b_in[ t_binw*]   &rarr; The binary word to fill with ones
 * \param    offset[t_uint64] &rarr; The position of the last bit to become a one
 *
 * The function will fill the binary word with ones from the least significant bit to the offset value
 **********************************************************************************************************************************************************************************************************************************/
t_binw *binw_fill_one( t_binw *b_in, t_uint64 offset )
{
    t_bit *b_out = NULL;

    if (b_in) //T0
    {
        if ( (b_out=binw_create()) ) //T1
        {
            t_uint64 i;
            for (i=0 ; i<BINW_SZ ; i++)
            {
                if (i<offset)
                    b_out[i]=b_in[i];

                else b_out[i]=1;
            }
        }
        else fprintf(logger, "bin.c::binw_fill_one.T1 -> b_out is NULL\n");
    }
    else fprintf(logger, "bin.c::binw_fill_one.T0 -> b_in is NULL\n");
    return b_out;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_binw *binw_not(t_binw *b_in)
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Applies the NOT logical operation to the binary word
 ***********************************************************************************************************************************************************************************************************************************
 * \param      b_in[t_binw*] &rarr; The binary word to which we apply the NOT operation
 * \return    b_out[t_binw]  &rarr; The binary word resulting of the NOT operation
 *
 * The function will apply the NOT function to a binary word, meaning that zeros become ones and ones become zeros
 **********************************************************************************************************************************************************************************************************************************/
t_binw *binw_not(t_binw *b_in)
{
    t_uint64 i;
    t_binw *b_out=NULL;
    if ( (b_out=binw_create()) ) // T0
        for (i=0 ; i<BINW_SZ ; i++)
        {
            if (b_in[i]==0){b_out[i]=1;}
            if (b_in[i]==1){b_out[i]=0;}
        }

    else fprintf(logger, "bin.c::bit_not.T0 -> b_out is NULL\n");
    return b_out;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn void binw_not_void(t_binw *b_in)
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Applies the NOT logical operation to the binary word itself
 ***********************************************************************************************************************************************************************************************************************************
 * \param      b_in[t_binw*] &rarr; The binary word to which we apply the NOT operation
 *
 * The function will apply the NOT function to a binary word, meaning that zeros become ones and ones become zeros
 **********************************************************************************************************************************************************************************************************************************/
void binw_not_void(t_binw *b_in)
{
    if (b_in) //T0
    {
        t_uint64 i;
        for (i=0 ; i<BINW_SZ ; i++)
        {
            if (b_in[i]==0){b_in[i]=1;}
            if (b_in[i]==1){b_in[i]=0;}
        }
    }
    else fprintf(logger, "bin.c::binw_not_void.T0 -> b_in is NULL\n");
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_binw *binw_1_complement(t_binw *b_in)
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Performs a complement à 1 of a binary word
 ***********************************************************************************************************************************************************************************************************************************
 * \param     b_in[t_binw*] &rarr; The binary word to which we apply the complement a 1
 * \return    b_out[t_binw] &rarr; The binary word resulting of the complement a 1 operation
 *
 * Si quelqu'un sait traduire complément à 1 faite le moi savoir xD
 **********************************************************************************************************************************************************************************************************************************/
t_binw *binw_1_complement(t_binw *b_in)
{
    t_bit *b_out=NULL;
    if (b_in) //T0
    {
        t_bit *b_not=NULL;
        if( (b_not=binw_not(b_in)) ) //T1
        {
            t_bit *one = NULL;
            if ( (one=binw_create()) ) //T2
            {
                one[0]=1;
                t_uint64 i,limit=1;
                for (i=0;i<(unsigned short)(BINW_SZ-2);i++)
                    if (b_in[i]!=0)
                        limit=0;

                if (!limit)
                {
                    if ( !(b_out=binw_add(b_not, one)) ) //T3
                        fprintf(logger, "bin.c::binw_1_complement.T3 -> binw_add returned NULL\n");
                }

                else
                    if ( !(b_out=binw_add_limit(b_not, one)) ) //T4
                        fprintf(logger, "bin.c::binw_1_complement.T4 -> binw_add returned NULL\n");

                binw_destroy(one);
            }
            else fprintf(logger, "bin.c::binw_1_complement.T2 -> one is NULL\n");
            binw_destroy(b_not);
        }
        else fprintf(logger, "bin.c::binw_1_complement.T1 -> b_not is NULL\n");
    }
    else fprintf(logger, "bin.c::binw_1_complement.T0 -> b_in is NULL\n");
    return b_out;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_binw *binw_get_absolute_value(t_binw *b)
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Returns the absolute value of a binary word
 ***********************************************************************************************************************************************************************************************************************************
 * \param      b_in[t_binw*] &rarr; The binary word to which we apply the absolute value
 * \return    b_out[t_binw] &rarr; The binary word resulting of the absolute value operation
 *
 **********************************************************************************************************************************************************************************************************************************/
t_binw *binw_get_absolute_value(t_binw *b)
{
    t_binw *p=NULL;
    if (b) //T0
    {
        if(b[BINW_SZ-1]==1)
        {
            t_bit *b_not=NULL;
            if ( (b_not=binw_not(b)) ) //T1
            {

                t_bit *one=NULL;
                if ( (one=binw_create()) ) //T2
                {
                    one[0]=1;
                    t_uint64 i,limit=1;
                    for (i=0;i<(unsigned short)(BINW_SZ-2);i++)
                        if (b_not[i]!=0)
                            limit=0;

                    if (!limit)
                    {
                        if ( !(p=binw_add(b_not, one)) ) //T3
                            fprintf(logger, "bin.c::binw_get_absolute_value.T3 -> binw_add returned NULL\n");
                    }

                    else
                        if ( !(p=binw_add_limit(b_not, one)) ) //T4
                            fprintf(logger, "bin.c::binw_get_absolute_value.T4 -> binw_add returned NULL\n");

                    binw_destroy(one);
                }
                else fprintf(logger, "bin.c::binw_get_absolute_value.T2 -> one is NULL\n");
                binw_destroy(b_not);
            }
            else fprintf(logger, "bin.c::binw_get_absolute_value.T1 -> b_not is NULL\n");
        }
        else return b;
    }
    else fprintf(logger, "bin.c::binw_get_absolute_value.T0 -> b is NULL\n");
    return p;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn void binw_1_complement_void(t_binw *b)
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Performs a "complement a 1" of a binary word by modifying the binary word itself
 ***********************************************************************************************************************************************************************************************************************************
 * \param      b_in[t_binw*] &rarr; A binary word
 *
 **********************************************************************************************************************************************************************************************************************************/
void binw_1_complement_void(t_binw *b)
{
    t_bit *p=NULL;
    if (b)
    {
        t_bit *b_not=NULL;
        if (b_not=binw_not(b)) //T1
        {
            t_bit *one = NULL;
            if ( one=binw_create() ) //T2
            {
                one[0]=1;
                t_uint64 i,limit=1;
                for (i=0;i<(unsigned short)(BINW_SZ-2);i++)
                    if (b[i]!=0)
                        limit=0;

                if (!limit)
                {
                    if ( !(p=binw_add(b_not, one)) ) //T3
                        fprintf(logger, "bin.c::binw_1_complement_void.T3 -> binw_add returned NULL\n");
                }

                else
                {
                    if ( !(p=binw_add_limit(b_not, one)) ) //T4
                        fprintf(logger, "bin.c::binw_1_complement_void.T4 -> binw_add returned NULL\n");
                }

                if(p) //T5
                {
                    for (i=0;i<BINW_SZ;i++)
                        b[i]=p[i];
                }
                else fprintf(logger, "bin.c::binw_1_complement_void.T5 -> p is NULL because T3 or T4 failed \n");
                binw_destroy(p);
                binw_destroy(one);
            }
            else fprintf(logger, "bin.c::binw_1_complement_void.T2 -> one is NULL\n");
            binw_destroy(b_not);
        }
        else fprintf(logger, "bin.c::binw_1_complement_void.T1 -> b_not is NULL\n");
    }
    else fprintf(logger, "bin.c::binw_1_complement_void.T0 -> b is NULL\n");
}


/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_binw *bit_add(t_bit a, t_bit b, t_bit r)
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Applies rules of the binary add function
 ***********************************************************************************************************************************************************************************************************************************
 * \param      a[t_bit] &rarr; Bit to be processed
 * \param      b[t_bit] &rarr; Bit to be processed
 * \param      r[t_bit] &rarr; Bit representing a possible carry
 * \return     s[t_binw*] &rarr; Result of a+b+r
 *
 * The function will return an array (s) with 2 values \n
 * s[0] stocks the result of the addition between the bits a and b \n
 * s[1] stocks the result of the carry
 **********************************************************************************************************************************************************************************************************************************/
t_binw *bit_add(t_bit a, t_bit b, t_bit r)
{
    t_binw *s=NULL;
    if((s=binw_create())) //T0
    {
        if ( a==0 && b==0 && r==0)                                                  {s[0]=0; s[1]=0;}
        if ( a==1 && b==1 && r==1)                                                  {s[0]=1; s[1]=1;}
        if ((a==0 && b==0 && r==1)||(a==0 && b==1 && r==0)||(a==1 && b==0 && r==0)) {s[0]=1; s[1]=0;}
        if ((a==0 && b==1 && r==1)||(a==1 && b==0 && r==1)||(a==1 && b==1 && r==0)) {s[0]=0; s[1]=1;}
    }
    else fprintf(logger,"bin.c::bit_add.T0 -> s is NULL\n");
    return s;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_bit binw_get_effective_sz(t_binw *b_in)
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Returns the position of last bit
 ***********************************************************************************************************************************************************************************************************************************
 * \param      b_in[t_binw*] &rarr; The binary word to which, we want to retrieve the effective size.
 * \return     sz[t_bit] &rarr; The effective size of the binary word
 *
 * The binary words are stored in an array of which the size is constant "BINW_SZ". \n
 * This size is ruled by the maximum of chosen bits to represent a binary word in the function binw_set_sz. \n
 * Meaning that after the MSB, it might still exist some zeros. \n
 * The effective size does not take in account theses zeros.
 **********************************************************************************************************************************************************************************************************************************/
t_bit binw_get_effective_sz(t_binw *b_in)
{
    t_bit sz=0;
    if(b_in) //T0
    {
        t_uint64 i=0;
        for (i=0;i<(unsigned short)(BINW_SZ-1);i++)
            if (b_in[i]==1)
                sz=i+1;
    }
    else fprintf(logger,"bin.c::binw_get_effective_sz.T0 -> b_in is NULL\n");
    return sz;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_uint64 binw_cmp_effective_sz(t_binw *a, t_binw *b)
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Compares the effective sizes between two binary words
 ***********************************************************************************************************************************************************************************************************************************
 * \param      a[t_binw*] &rarr; A binary word
 * \param      b[t_binw*] &rarr; A binary word
 * \return    sz[t_uint64] &rarr; Delta in bits of the binary word's effective size
 *
 * Substracts the 2 effective sizes and return the result. \n
 * if effective_sz(a)-effective_sz(b) < 0 then a < b \n
 * else a > b \n
 * Actually, this function determines which of the 2 binary words is the greater one.
 **********************************************************************************************************************************************************************************************************************************/
t_uint64 binw_cmp_effective_sz(t_binw *a, t_binw *b)
{
    t_uint64 sz=0;
    if(a&&b) //T0
        sz=binw_get_effective_sz(a)-binw_get_effective_sz(b);

    else fprintf(logger, "bin.c::binw_cmp_effective_sz.T0 -> a or/and is NULL\n");
    return sz;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_uint64 binw_multiply_get_new_sz(t_binw *a, t_binw *b)
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Determines the size of the binary word after multiplication
 ***********************************************************************************************************************************************************************************************************************************
 * \param      a[t_binw*] &rarr; A binary word
 * \param      b[t_binw*] &rarr; A binary word
 * \return    sz[t_uint64] &rarr; Size of the binary word resulting of the a*b operation
 *
 * This pass will allow to check if there is a possible carry overflow since the binary word is 64 signed bits long
 **********************************************************************************************************************************************************************************************************************************/
t_uint64 binw_multiply_get_new_sz(t_binw *a, t_binw *b)
{
    t_uint64 shift=0;
    t_uint64 max_sz=0;
    t_uint64 r=0;
    if(a&&b)
    {
        t_bit a_sz = binw_get_effective_sz(a);
        t_bit b_sz = binw_get_effective_sz(b);
        if (binw_cmp_effective_sz(a,b)<=0)
            shift=a_sz,max_sz=b_sz;

        else shift = b_sz, max_sz=a_sz;
    }
    else fprintf(logger, "bin.c::binw_multiply_get_new_sz-> a and/or b is NULL\n");
    r=shift+max_sz;

    if ( r > BINW_SZ )
        fprintf(logger, "bin.c::binw_multiply_get_new_sz-> r=%I64u\n",r), r=BINW_SZ;

    return r;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_uint64 binw_multiply_check_carry_overflow(t_binw *a, t_binw *b)
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Determines if the multiplication of the binary words will lead or not to a carry overflow
 ***********************************************************************************************************************************************************************************************************************************
 * \param      a[t_binw*] &rarr; A binary word
 * \param      b[t_binw*] &rarr; A binary word
 * \return    carry_overflow[t_uint64] &rarr; Flag representing a possible carry overflow
 *
 **********************************************************************************************************************************************************************************************************************************/
t_uint64 binw_multiply_check_carry_overflow(t_binw *a, t_binw *b)
{
    unsigned short carry_overflow=FALSE;
    if (a&&b)
    {
        if(binw_multiply_get_new_sz(a,b)>BINW_SZ)
            carry_overflow=TRUE;
    }
    else
    {
        if(!a)
            fprintf(logger, "bin.c::binw_multiply_check_carry_overflow_sz-> a is NULL\n");
        if(!b)
            fprintf(logger, "bin.c::binw_multiply_check_carry_overflow_sz-> b is NULL\n");
    }
    return carry_overflow;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn void binw_add_recursive(t_binw **matrix, unsigned short matrix_sz, unsigned short index_sz, t_binw **partial_sum)
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Child function of binw_add
 ***********************************************************************************************************************************************************************************************************************************
 * \param          matrix[t_binw**]
 * \param       matrix_sz[unsigned short]
 * \param        index_sz[unsigned short]
 * \param     partial_sum[t_binw*]
 *
 **********************************************************************************************************************************************************************************************************************************/
void binw_add_recursive(t_binw **matrix, unsigned short matrix_sz, unsigned short index_sz, t_binw **partial_sum)
{
    if( matrix )
    {
        if( index_sz < matrix_sz )
        {
            if( (*partial_sum) == NULL && index_sz == 0 ) /* At the first iteration, partial_sum need to be allocated */
            {
                if ( !((*partial_sum)=binw_create()) )
                    fprintf(logger, "bin.c::binw_add_recursive -> binw_create returned NULL\n");
            }
            else /* In case that partial_sum is getting NULL during the process */
            {
                if ( (*partial_sum)==NULL && index_sz > 0 )
                    fprintf(logger, "bin.c::binw_add_recursive -> partial_sum is NULL but it should not NULL\n");
            }

            if ( (*partial_sum) ) /* If partial_sum is not NULL then we can proceed */
            {
                index_sz++;
                (*partial_sum)=binw_add(*partial_sum, matrix[index_sz-1]);
                binw_add_recursive(matrix, matrix_sz, index_sz, partial_sum);
            }
        }
    }
    else fprintf(logger, "bin.c::binw_add_recursive-> matrix is NULL\n");
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_binw **binw_get_matrix(t_binw *a, t_binw *b, t_uint64 *binw_array_sz)
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Creates and fills the required matrix to finalize the multiplication between the binary word a & b
 ***********************************************************************************************************************************************************************************************************************************
 * \param       a[t_binw*]
 * \param       b[t_binw*]
 * \param       binw_array_sz[t_uint64*]
 * \return      binw_array[t_binw**]
 *
 **********************************************************************************************************************************************************************************************************************************/
t_binw **binw_get_matrix(t_binw *a, t_binw *b, t_uint64 *binw_array_sz)
{
    t_binw **binw_array=NULL;
    if (a&&b) //T0
    {
        *binw_array_sz=0;
        if ( (*binw_array_sz=binw_get_effective_sz(a)) != 0)
        {
            if ((binw_array=allocate_2D_us(*binw_array_sz,BINW_SZ))) //T1
            {
                t_uint64 i,j;
                for (i=0;i<*binw_array_sz;i++)
                     for(j=0;j<BINW_SZ;j++)
                        if (j+i<BINW_SZ)
                            binw_array[i][j+i]=a[i]&b[j];
            }
            else fprintf(logger, "bin.c::binw_get_matrix.T1-> binw_array is NULL\n");
        }
        else fprintf(logger, "bin.c::binw_get_matrix.T1-> binw_get_effective_sz returned 0\n");
    }
    else
    {
        if(!a)
            fprintf(logger, "bin.c::binw_get_matrix.T0 -> a is NULL\n");
        if(!b)
            fprintf(logger, "bin.c::binw_get_matrix.T0 -> b is NULL\n");
    }
    return binw_array;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_bit binw_multiply_get_sign( t_binw *a, t_binw *b )
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Determines the sign of the multiplication between the binary world a & b
 ***********************************************************************************************************************************************************************************************************************************
 * \param       a[t_binw*] &rarr; A binary word
 * \param       b[t_binw*] &rarr; A binary word
 * \return      sign[t_bit] &rarr; The sign of the resulting multiplication of the binary words a*b
 *
 * If sign = 0 then a*b >= 0 \n
 * If sign = 1 then a*b < 0 \n
 * If sign = 2 then a and or b is NULL
 **********************************************************************************************************************************************************************************************************************************/
t_bit binw_multiply_get_sign( t_binw *a, t_binw *b )
{
    t_bit sign=2;
    if(a&&b) //T0
    {
        if      ( a[BINW_SZ-1] == b[BINW_SZ-1] ){sign=0;}
        else if ( a[BINW_SZ-1] != b[BINW_SZ-1] ){sign=1;}
        else fprintf(logger, "bin.c::binw_multiply_get_sign -> Something really wrong happened\n");
    }
    else
    {
        if(!a)
            fprintf(logger, "bin.c::binw_multiply_get_sign.T0 -> a is NULL\n");
        if(!b)
            fprintf(logger, "bin.c::binw_multiply_get_sign.T0 -> b is NULL\n");
    }
    return sign;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_binw *binw_cpy(t_binw *b_in)
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Copies a binary word into a new one
 ***********************************************************************************************************************************************************************************************************************************
 * \param       b_in[t_binw*] &rarr; The binary word to copy
 * \return      b_out[t_binw*] &rarr; The binary word copied
 *
 **********************************************************************************************************************************************************************************************************************************/
t_binw *binw_cpy(t_binw *b_in)
{
    t_binw *b_out = NULL;
    if ( b_in ) //T0
    {
        if ( (b_out=binw_create()) ) //T1
        {
            t_uint64 i=0;
            for (i=0; i<BINW_SZ ;i++)
                b_out[i]=b_in[i];
        }
        else fprintf(logger, "bin.c::binw_cpy.T1 -> b_out is NULL\n");
    }
    else fprintf(logger, "bin.c::binw_cpy.T0 -> b_in is NULL\n");
    return b_out;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_bit binw_zero_compare(t_binw *b_in)
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Check if the binary word is equal to 0
 ***********************************************************************************************************************************************************************************************************************************
 * \param       b_in[t_binw*] &rarr; A binary word
 * \return      cmp[t_bit] &rarr; Stores the result of the comparison
 *
 * If cmp = 0 then b_in != 0 \n
 * If cmp = 1 then b_in  = 0
 **********************************************************************************************************************************************************************************************************************************/
t_bit binw_zero_compare(t_binw *b_in)
{
    t_bit cmp=TRUE;
    if ( b_in ) //T0
    {
        t_uint64 i;
        for(i=0;i<(t_uint64)BINW_SZ;i++)
                if (b_in[i]!=0)
                    cmp=FALSE;
    }
    else fprintf(logger, "bin.c::binw_zero_compare.T0 -> b_in is NULL\n");
    return cmp;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_binw *binw_multiply(t_binw *a, t_binw *b)
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Multiplies the binary words a & b
 ***********************************************************************************************************************************************************************************************************************************
 * \param       a[t_binw*] &rarr; A binary word
 * \param       b[t_binw*] &rarr; A binary word
 * \return      binw_multiply[t_binw*] &rarr; The binary word resulting of the multiplication a*b
 *
 **********************************************************************************************************************************************************************************************************************************/
t_binw *binw_multiply(t_binw *a, t_binw *b)
{
    t_binw *binw_multiplied=NULL;
    if(a&&b)
    {
        /* If none of the factors are equals to zero, continue the process */
        if ( (binw_zero_compare(a)==FALSE && binw_zero_compare(b)==FALSE) )
        {
            /* Determine the sign of the result */
            t_bit binw_multiplied_sign = 0;
            if ( (binw_multiplied_sign=binw_multiply_get_sign(a,b)) != 2 )
            {
                t_bit a_sign = 0;
                t_bit b_sign = 0;

                /* If factors are negatives, to complete the process, we must work with positive values, the sign will be applied at the end of the process */
                if((a_sign=binw_check_sign(a))==1)
                    binw_1_complement_void(a);

                if((b_sign=binw_check_sign(b))==1)
                    binw_1_complement_void(b);

                /* Determines if the multiplication will lead to a carry overflow */
                if(binw_multiply_check_carry_overflow(a,b)==FALSE)
                {
                    /* This array will stock each sub-factors of the multiplication process */
                    t_binw **binw_array=NULL;
                    t_uint64 binw_array_sz=0;

                    /* Determines which factor is the greater one, this allows to reduce the number of sub-factors */
                    t_boolean get_matrix=TRUE;
                    if (binw_cmp_effective_sz(a,b)<=0)
                    {
                        if ( !(binw_array=binw_get_matrix(a, b, &binw_array_sz)) )
                            get_matrix=FALSE;
                    }
                    else
                    {
                        if ( !(binw_array=binw_get_matrix(b, a, &binw_array_sz)) )
                            get_matrix=FALSE;
                    }

                    if ( get_matrix==TRUE )
                    {
                        unsigned short index_sz=0;
                        t_binw *binw_sum=NULL;
                        binw_add_recursive(binw_array, binw_array_sz, index_sz, &binw_sum);
                        if ( (binw_sum) ) /* Add all the sub-factors */
                        {
                            deallocate_2D_us(binw_array,binw_array_sz);

                            /* If the sign of the result was a negative one, then we get the negative representation of this positive value */
                            if (binw_multiplied_sign==1)
                                binw_1_complement_void(binw_sum);

                            /* If the resulting sign was supposed to be positive and the signed bit is set to negative value, then this case lead to a carry overflow */
                            if (binw_multiplied_sign==0 && binw_sum[BINW_SZ-1]==1)
                                fprintf(logger, "bin.c::binw_multiply -> Carry overflow\n"), binw_destroy(binw_multiplied);

                            else
                            {
                                binw_multiplied=binw_cpy(binw_sum);
                                binw_destroy(binw_sum);
                            }
                        }
                        else fprintf(logger, "bin.c::binw_multiply -> binw_add_recursive returned NULL\n");
                    }
                    else fprintf(logger, "bin.c::binw_multiply -> get_matrix is FALSE\n");
                }
                else fprintf(logger, "bin.c::binw_multiply -> Carry overflow\n");
            }
            else fprintf(logger, "bin.c::binw_multiply -> binw_multiply_get_sign returned 2\n");
        }
        /* Else there is no need to continue since we know the result is zero  */
        else
        {
            if ( !(binw_multiplied=binw_create()) )
                fprintf(logger,"bin.c::binw_multiply -> binw_create returned NULL\n");
        }
    }
    else
    {
        if (!a)
            fprintf(logger,"bin.c::binw_multiply -> a is NULL\n");
        if (!b)
            fprintf(logger,"bin.c::binw_multiply -> b is NULL\n");
    }
    return binw_multiplied;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_bit binw_cmp(t_binw *a, t_binw *b)
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Compares the two binary words a & b
 ***********************************************************************************************************************************************************************************************************************************
 * \param       a[t_binw*] &rarr; A binary word
 * \param       b[t_binw*] &rarr; A binary word
 * \return      arg[t_bit] &rarr; Stores the result of the comparison of a-b
 *
 * if arg = 0 then an error occurred, a and/or b is NULL \n
 * if arg = 1 then a > b \n
 * if arg = 2 then b > a \n
 * if arg = 3 then b = a
 **********************************************************************************************************************************************************************************************************************************/
t_bit binw_cmp(t_binw *a, t_binw *b)
{
    t_bit arg=0;
    if (a&&b) //T0
    {
        t_uint64 i;
        for (i=BINW_SZ-1;i>0;i--)
        {
            if(a[i]!=b[i])
            {
                if (a[i]==1) /* a is greater than b */
                    arg=1,i=1;

                else arg=2,i=1;  /* b is greater than a */
            }
        }
        if (arg==0)
            arg=3;  /* a is equal to b */
    }
    else
    {
        if (a==NULL)
            fprintf(logger,"bin.c::binw_cmp.T0 -> a is NULL\n");
        if (b==NULL)
            fprintf(logger,"bin.c::binw_cmp.T0 -> b is NULL\n");
    }
    return arg;
}


/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_bit binw_add_get_sign(t_binw *a, t_binw *b)
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Determines the final sign of a binary addition
 ***********************************************************************************************************************************************************************************************************************************
 * \param       a[t_binw*] &rarr; A binary word
 * \param       b[t_binw*] &rarr; A binary word
 * \return      sign[t_bit] &rarr; Resulting sign of the addition of a+b
 *
 * if sign = 0 then a+b >= 0  \n
 * if sign = 1 then a+b < b  \n
 * if sing = 2 then an error occurred, a and/or b are not properly allocated
 *
 **********************************************************************************************************************************************************************************************************************************/
t_bit binw_add_get_sign(t_binw *a, t_binw *b)
{
    t_bit sign=2;
    if(a&&b) //T0
    {
        /* If the the sign of both binary words are the same, then the resulting one will be the same */
        if(a[BINW_SZ-1]==b[BINW_SZ-1])
           sign=a[BINW_SZ-1];

        /* Else we have to determine which binary word is the greater one so we will able to get the resulting sign of the addition */
        else
        {
            t_bit cmp;
            t_binw *a_abs = NULL;
            if ( (a_abs=binw_get_absolute_value(a)) ) //T1
            {
                t_binw *b_abs = NULL;
                if ( (b_abs=binw_get_absolute_value(b)) ) //T2
                {
                    if (cmp = binw_cmp(a_abs, b_abs) != 0 ) //T3
                    {
                        if (cmp==3) /* a and b are equals */
                        {
                            if (a[BINW_SZ-1]==1 && b[BINW_SZ-1]==1) /* Both are negatives means sign will be negative */
                                sign=1;

                            else sign=0; /* Else sign will be positive */
                        }
                        else  /*a or b is greater than the other one*/
                        {
                            if ((a[BINW_SZ-1]==0 && cmp==1) /* a>0 & a>b */ || (a[BINW_SZ-1]==1 && cmp==2)) /* a<0 & a<b */ {sign=0;} /* Resulting sign will be positive */
                            if ((a[BINW_SZ-1]==0 && cmp==2) /* a>0 & a<b */ || (a[BINW_SZ-1]==1 && cmp==1)) /* a<0 & a>b */ {sign=1;} /* Resulting sign will be negative */
                        }
                    }
                    else fprintf(logger,"bin.c::binw_add_get_sign.T3 -> binw_cmp returned a value that it should never reach : %d\n", cmp);
                }
                else fprintf(logger,"bin.c::binw_add_get_sign.T2 -> binw_get_absolute_value returned NULL (b_abs)\n");
            }
            else fprintf(logger,"bin.c::binw_add_get_sign.T1 -> binw_get_absolute_value returned NULL (a_abs)\n");
        }
    }
    else fprintf(logger,"bin.c::binw_add_get_sign.T0 -> a and/or b is NULL\n");
    return sign;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_binw *binw_add(t_binw *a, t_binw *b)
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Add two binary words
 ***********************************************************************************************************************************************************************************************************************************
 * \param       a[t_binw*] &rarr; A binary word
 * \param       b[t_binw*] &rarr; A binary word
 * \return      s[t_binw*] &rarr; The resulting binary word of the addition a+b
 *
 **********************************************************************************************************************************************************************************************************************************/
t_binw *binw_add(t_binw *a, t_binw *b)
{
    t_binw *r=NULL; /* Array to stock the carries */
    t_binw *s=NULL; /* Array to stock the result of the addition */
    t_bit sign=2;
    if (a&&b) //T0
    {
        if ((sign=binw_add_get_sign(a,b))!=2) /* T1 Getting the supposed resulting sign of the addition */
        {
            if ( (r=binw_create()) && (s=binw_create()) ) //T2
            {
                t_uint64 i;
                for (i=0 ; i<BINW_SZ ; i++)
                {
                    t_binw *c=NULL; /* To stock the result of the addition and the carry */
                    if ( (c=bit_add(a[i],b[i],r[i])) ) /* T3 adding bit a[i] and b[i] giving c[0]=a&b and c[1]=carry for the next addition */
                    {
                        s[i]=c[0];
                        if (i<(unsigned short)(BINW_SZ-1))
                            r[i+1]=c[1];
                    }
                    else fprintf(logger, "bin.c::binw_add.T3 -> c is NULL, i=%I64u\n", i);
                    binw_destroy(c);
                }
                if (sign != s[BINW_SZ-1]) /* Checking if the computed sign is the supposed one, else it means that there is a carry overflow */
                {
                    fprintf(logger, "bin.c::binw_add -> Carry overflow for %lld + %lld \n", binw_to_dec(a), binw_to_dec(b));
                    binw_destroy(s);
                    s=NULL;
                }
            }
            else fprintf(logger, "bin.c::binw_add.T2 -> r and/or s is NULL\n");
        }
        else fprintf(logger, "bin.c::binw_add.T1 -> binw_add_get_sign returned sign=%d \n", sign);
        binw_destroy(r);
    }
    else
    {
        if (a==NULL)
            fprintf(logger, "bin.c::binw_add.T0 -> a is NULL\n");
        if (b==NULL)
            fprintf(logger, "bin.c::binw_add.T0 -> b is NULL\n");
    }
    return s;
}


/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_binw *binw_add_limit(t_binw *a, t_binw *b)
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Adds two binary word (no carry overflow check)
 ***********************************************************************************************************************************************************************************************************************************
 * \param       a[t_binw*] &rarr; A binary word
 * \param       b[t_binw*] &rarr; A binary word
 * \return      s[t_binw*] &rarr; The resulting binary word of the addition a+b
 *
 **********************************************************************************************************************************************************************************************************************************/
t_binw *binw_add_limit(t_binw *a, t_binw *b)
{
    t_binw *r=NULL; /* Array to stock the carries */
    t_binw *s=NULL; /* Array to stock the result of the addition */
    t_bit sign=2;
    if (a&&b) //T0
    {
        if ((sign=binw_add_get_sign(a,b))!=2) /* T1 Getting the supposed resulting sign of the addition */
        {
            if ( (r=binw_create()) && (s=binw_create()) ) //T2
            {
                t_uint64 i;
                for (i=0 ; i<BINW_SZ ; i++)
                {
                    t_binw *c=NULL; /* To stock the result of the addition and the carry */
                    if ( (c=bit_add(a[i],b[i],r[i])) ) /* T3 adding bit a[i] and b[i] giving c[0]=a&b and c[1]=carry for the next addition */
                    {
                        s[i]=c[0];
                        if (i<(unsigned short)(BINW_SZ-1))
                            r[i+1]=c[1];
                    }
                    else fprintf(logger, "bin.c::binw_add_limit.T3 -> c is NULL\n");
                    binw_destroy(c);
                }
            }
            else fprintf(logger, "bin.c::binw_add_limit.T2 -> r and/or s is NULL\n");
        }
        else fprintf(logger, "bin.c::binw_add_limit.T1 -> Even if T0 passed, a and/or b is NULL \n");
        binw_destroy(r);
    }
    else fprintf(logger, "bin.c::binw_add_limit.T0 -> a and/or b is NULL\n");
    return s;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_binw *dec_to_binw( long long int x )
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Convert a decimal number to its binary representation
 ***********************************************************************************************************************************************************************************************************************************
 * \param       x[long long int] &rarr; The decimal value to convert
 * \return      b_out[t_binw*] &rarr; The resulting binary word of the convertion
 *
 **********************************************************************************************************************************************************************************************************************************/
t_binw *dec_to_binw( long long int x )
{
    unsigned long long bit = 1;
    t_uint64 i;
    t_binw *b_out = NULL;
    if (x>=0)
    {
        if ( (b_out=binw_create()) ) //T0
            for (i=0 ; i<BINW_SZ ; i++)
                b_out[i] = (x & bit)>>i, bit <<= 1;

        else fprintf(logger, "bin.c::dec_to_binw.T0 -> b_out is NULL, x=%lld\n", x);
    }
    else
    {
        if (x == -1)
        {
            b_out = binw_fill_one(binw_create(), 0);
        }

        else if (x==LLONG_MIN)
        {
            t_binw *t=NULL;
            if ( (t=dec_to_binw(-x-1)) ) //T0
            {
                t_binw *one=NULL;
                if ( (one=binw_create()) ) //T1
                {
                    one[0]=1;
                    if ( !(b_out=binw_add_limit(t,one)) ) //T2
                        fprintf(logger, "bin.c::dec_to_binw.T2 -> b_out is NULL, x=%lld\n", x);
                }
                else fprintf(logger, "bin.c::dec_to_binw.T1 -> one is NULL, x=%lld\n", x);

            }
            else fprintf(logger, "bin.c::dec_to_binw.T0 -> t is NULL, x=%lld\n", x);

        }
        else
        {
            if ( !(b_out=binw_1_complement(dec_to_binw(-x))) ) //T3
                fprintf(logger, "bin.c::dec_to_binw.T3 -> b_out is NULL, x=%lld\n", x);
        }
    }
    return b_out;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn long long int binw_to_dec(t_binw *b_in)
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Convert a binary word to its decimal representation
 ***********************************************************************************************************************************************************************************************************************************
 * \param       b_in[t_binw*] &rarr; A binary word
 * \return      d[long long int] &rarr; The corresponding decimal value of the binary word
 *
 **********************************************************************************************************************************************************************************************************************************/
long long int binw_to_dec(t_binw *b_in)
{
    t_uint64 bit = 1;
    long long int d=0;
    if(b_in) //T0
    {
        t_uint64 i;
        if (b_in[BINW_SZ-1]==0)
            for(i=0 ; i<BINW_SZ ; i++)
                d += b_in[i]*(bit<<i);

        else
        {
            t_bit *r=NULL;
            if ( (r=binw_1_complement(b_in)) ) //T1
            {
                for(i=0 ; i<BINW_SZ ; i++)
                    d -= r[i]*(bit<<i);

                binw_destroy(r);
            }
            else fprintf(logger, "bin.c::binw_to_dec.T1 -> binw_1_complement returned NULL\n");
        }
    }
    else fprintf(logger, "bin.c::binw_to_dec.T0 -> b_in is NULL\n");
    return d;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn t_binw *str_to_bin(const char *str, t_uint64 *binw_sz)
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Convert a string into its binary representation
 ***********************************************************************************************************************************************************************************************************************************
 * \param       str[const char *] &rarr; The string to convert
 * \param       binw_sz[t_uint64 *] &rarr; The size of the binary word
 * \return      b_out[t_binw*] &rarr; The string converted to a binary word
 *
 **********************************************************************************************************************************************************************************************************************************/
t_binw *str_to_binw(const char *str, t_uint64 *binw_sz, t_uint64 sz)
{
    t_uint64 str_sz = str_length(str);
    *binw_sz=str_sz*sz;
    t_binw *b_out=NULL;
    if ((b_out=binw_create_dyn(*binw_sz))) //TO
    {
        t_uint64 i,j;
        for (i=0;i<str_sz;i++)
        {
            t_binw *c = NULL;
            if ((c=dec_to_binw(str[i]))) //T1
            {
                for(j=0;j<sz;j++)
                    b_out[i*sz+j]=c[j];

                binw_destroy(c);
            }
            else fprintf(logger, "bin.c::str_to_bin.T1 -> c is NULL @ i=%I64u\n", i);
        }
    }
    else fprintf(logger, "bin.c::str_to_bin.T0 -> b_out is NULL\n");
    return b_out;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn char *binw_to_str(t_binw *b, t_uint64 b_sz, t_uint64 *str_sz, t_uint64 binw_sz)
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Concert a binary word into a string
 ***********************************************************************************************************************************************************************************************************************************
 * \param       b_in[t_binw *] &rarr; The binary word you want to translate into a string
 * \param       b_sz[t_uint64] &rarr; The size of the binary word b_in
 * \param       str_sz[t_uint64*] &rarr; The length of the sting s_out
 * \param       binw_sz[t_uint64] &rarr; The size of a binary word into
 * \return      s_out[char *] &rarr; The binary word converted into a string
 *
 **********************************************************************************************************************************************************************************************************************************/
char *binw_to_str(t_binw *b_in, t_uint64 b_sz, t_uint64 *str_sz, t_uint64 binw_sz)
{
    char *s_out = NULL;
    if (b_in) //T0
    {
        if ( b_sz > 0 ) //T1
        {
            t_uint64 r=0;
            if ( b_sz%binw_sz == 0 )
                *str_sz = b_sz/binw_sz;

            else
            {
                r = b_sz - (int)(1.*b_sz/binw_sz);
                *str_sz = b_sz/binw_sz +1 ;
            }

            if ( (s_out = allocate_1D_c(*str_sz+1)) ) // T2
            {
                t_uint64 i,j,k;
                t_binw *b_tmp = NULL;
                if ( (b_tmp = binw_create_random(binw_sz)) ) //T3
                {
                    k=0;
                    for ( i=0 ; i<*str_sz ; i++ )
                    {
                        for ( j=0 ; j<binw_sz ; j++ )
                        {
                            b_tmp[j]=b_in[k+j];
                            if ( j == r-1 )
                                b_tmp[j]=0;
                        }
                        k+=binw_sz;
                        t_uint64 d = binw_to_dec(b_tmp);
                        s_out[i]=(char)d;
                    }
                    binw_destroy(b_tmp);
                }
                else fprintf(logger, "bin.c::binw_to_str.T3 -> b_tmp is NULL\n");
            }
            else fprintf(logger, "bin.c::binw_to_str.T2 -> b_tmp is NULL\n");
        }
        else fprintf(logger, "bin.c::binw_to_str.T1 -> b_sz <= 0\n");
    }
    else fprintf(logger, "bin.c::binw_to_str.T0 -> b NULL\n");
    return s_out;
}

/** *********************************************************************************************************************************************************************************************************************************
 * \fn void bin_example()
 ***********************************************************************************************************************************************************************************************************************************
 * \brief Function that shows how to use the functions of this library
 *
 ***********************************************************************************************************************************************************************************************************************************/

void bin_example()
{
    binw_set_sz(); // The first function to call. It sets the size of the binary words. Default is the size of long long int i.e 64 bits
    system("mode con lines=200 cols=150");

    printf("\n\n\n±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±> CREATE A BINARY WORD binw_create\n");
    t_binw *b0 = NULL;
    if ( (b0 = binw_create()) ) // This creates a binary words of 64 bits filled with zeros
    {
        binw_display(b0, "b0"); printf(" = %lld",binw_to_dec(b0));// This function displays the content of b0 with a header
        binw_destroy(b0); // This function deallocate the binary word b0
    }

    printf("\n\n\n±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±> CREATE A RANDOM BINARY WORD binw_create_random\n");
    t_binw *b2 = NULL;
    if ( (b2 = binw_create_random()) ) // This creates a 64 bits long random binary word .
    {
        binw_display(b2, "b2"); printf(" = %lld",binw_to_dec(b2));
        binw_destroy(b2);
    }

    printf("\n\n\n±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±> OR binw_or\n");
    t_binw *b3 = NULL;
    t_binw *b4 = NULL;
    t_binw *b5 = NULL;
    long long int d3 = 0;
    long long int d4 = 0;
    long long int d5 = 0;
    if ( (b3 = binw_create_random()) )
    {
        binw_display(b3, "         b3"); printf(" = %lld", binw_to_dec(b3));
        if ( (b4 = binw_create_random()) )
        {
            binw_display(b4, "         b4"); printf(" = %lld",binw_to_dec(b4));
            if ( (b5 = binw_or(b3,b4)) )
            {
                d5=binw_to_dec(b5);
                binw_display(b5, "b5=b2 OR b3"), printf(" = %lld", d5);

                binw_destroy(b5);
            }
            else printf("\n      b5 is NULL");

            binw_destroy(b4);
        }
        binw_destroy(b3);
    }

    printf("\n\n\n±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±> AND binw_and\n");
    d3 = 0;
    d4 = 0;
    d5 = 0;
    if ( (b3 = binw_create_random()) )
    {
        binw_display(b3, "          b3"); printf(" = %lld", binw_to_dec(b3));
        if ( (b4 = binw_create_random()) )
        {
            binw_display(b4, "          b4"); printf(" = %lld",binw_to_dec(b4));
            if ( (b5 = binw_and(b3,b4)) )
            {
                d5=binw_to_dec(b5);
                binw_display(b5, "b5=b2 AND b3"), printf(" = %lld", d5);

                binw_destroy(b5);
            }
            else printf("\n      b5 is NULL");

            binw_destroy(b4);
        }
        binw_destroy(b3);
    }

    printf("\n\n\n±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±> AND binw_xor\n");
    d3 = 0;
    d4 = 0;
    d5 = 0;
    if ( (b3 = binw_create_random()) )
    {
        binw_display(b3, "          b3"); printf(" = %lld", binw_to_dec(b3));
        if ( (b4 = binw_create_random()) )
        {
            binw_display(b4, "          b4"); printf(" = %lld",binw_to_dec(b4));
            if ( (b5 = binw_xor(b3,b4)) )
            {
                d5=binw_to_dec(b5);
                binw_display(b5, "b5=b2 XOR b3"), printf(" = %lld", d5);

                binw_destroy(b5);
            }
            else printf("\n      b5 is NULL");

            binw_destroy(b4);
        }
        binw_destroy(b3);
    }

    printf("\n\n\n±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±> STANDARD ADDITION binw_add\n");
    d3 = 10;
    d4 = -8;
    d5 = 0;
    if ( (b3 = dec_to_binw(d3)) ) // Converts 10 into the binary base
    {
        binw_display(b3, "      b3"); printf(" = %lld",d3);
        if (( (b4 = dec_to_binw(d4)) )) // Converts -8 into the binary base
        {
            binw_display(b4, "      b4"); printf(" = %lld",d4);
            if ( (b5 = binw_add(b3,b4)) ) // Adds the two binary words
            {
                d5=binw_to_dec(b5);
                if ( d5 == (d3+d4) ) // Converts a binary word into the decimal base
                    binw_display(b5, "b5=b2+b3"), printf(" = %lld", d5);

                binw_destroy(b5);
            }
            else
            {
                printf("\nb5 is NULL");
                printf("\nCheck the log for possible carry overflow");
            }
            binw_destroy(b4);
        }
        binw_destroy(b3);
    }

    printf("\n\n\n±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±> ADDITION AND CARRY OVERFLOW (LLONG_MAX) binw_add\n");
    d3 = LLONG_MAX;
    d4 = 1;
    d5 = 0;
    if ( (b3 = dec_to_binw(d3)) )
    {
        binw_display(b3, "      b3"); printf(" = %lld",d3);
        if (( (b4 = dec_to_binw(d4)) ))
        {
            binw_display(b4, "      b4"); printf(" = %lld",d4);
            if ( (b5 = binw_add(b3,b4)) )
            {
                d5=binw_to_dec(b5);
                if ( d5 == (d3+d4) )
                    binw_display(b5, "b5=b2+b3"), printf(" = %lld", d5);

                binw_destroy(b5);
            }
            else
            {
                printf("\n      b5 is NULL");
                printf("\n      Check the log for possible carry overflow");
            }
            binw_destroy(b4);
        }
        binw_destroy(b3);
    }

    printf("\n\n±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±> ADDITION AND CARRY OVERFLOW (LLONG_MIN) binw_add\n");
    d3 = LLONG_MIN;
    d4 = -1;
    d5 = 0;
    if ( (b3 = dec_to_binw(d3)) )
    {
        binw_display(b3, "      b3"); printf(" = %lld",d3);
        if (( (b4 = dec_to_binw(d4)) ))
        {
            binw_display(b4, "      b4"); printf(" = %lld",d4);
            if ( (b5 = binw_add(b3,b4)) )
            {
                d5=binw_to_dec(b5);
                if ( d5 == (d3+d4) )
                    binw_display(b5, "b5=b2+b3"), printf(" = %lld", d5);

                binw_destroy(b5);
            }
            else
            {
                printf("\n      b5 is NULL");
                printf("\n      Check the log for possible carry overflow");
            }
            binw_destroy(b4);
        }
        binw_destroy(b3);
    }

    printf("\n\n±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±> MULTIPLICATION binw_multiply\n");
    d3 = 6;
    d4 = -12;
    d5 = 0;
    if ( (b3 = dec_to_binw(d3)) )
    {
        binw_display(b3, "      b3"); printf(" = %lld",d3);
        if (( (b4 = dec_to_binw(d4)) ))
        {
            binw_display(b4, "      b4"); printf(" = %lld",d4);
            if ( (b5 = binw_multiply(b3,b4)) )
            {
                d5=binw_to_dec(b5);
                if ( d5 == (d3*d4) )
                    binw_display(b5, "b5=b2*b3"), printf(" = %lld", d5);

                binw_destroy(b5);
            }
            else
            {
                printf("\n      b5 is NULL");
                printf("\n      Check the log for possible carry overflow");
            }
            binw_destroy(b4);
        }
        binw_destroy(b3);
    }

    printf("\n\n±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±> MULTIPLICATION AND CARRY OVERFLOW binw_multiply\n");
    d3 = (long long int)sqrt( (double)LLONG_MAX )+1 ;
    d4 = (long long int)sqrt( (double)LLONG_MAX )+1 ;
    d5 = 0;
    if ( (b3 = dec_to_binw(d3)) )
    {
        binw_display(b3, "      b3"); printf(" = %lld",d3);
        if (( (b4 = dec_to_binw(d4)) ))
        {
            binw_display(b4, "      b4"); printf(" = %lld",d4);
            if ( (b5 = binw_multiply(b3,b4)) )
            {
                d5=binw_to_dec(b5);
                if ( d5 == (d3*d4) )
                    binw_display(b5, "b5=b2*b3"), printf(" = %lld", d5);

                binw_destroy(b5);
            }
            else
            {
                printf("\n      b5 is NULL");
                printf("\n      Check the log for possible carry overflow");
            }
            binw_destroy(b4);
        }
        binw_destroy(b3);
    }

    printf("\n\n±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±> CONVERTING A STR TO ITS BINARY REPRESENTATION AND ITS CONTRARY str_to_binw/binw_to_str\n");
    char *str = NULL;
    if ( (str=str_copy("Please turn me into binary")) )
    {
        t_uint64 str_sz=0;
        t_binw *b = NULL;
        if ( (b=str_to_binw(str, &str_sz, 8)) )
        {
            binw_display_dyn(b, str_sz, "str to binw");
            t_uint64 sz=0;
            char *s=NULL;
            if ( (s=binw_to_str(b, str_sz, &sz, 8)) )
            {
                display_1D_c(s, sz, "binw to str");
                deallocate_1D_c(s);
            }
            else printf("\nbinw_to_str returned NULL");
            binw_destroy(b);
        }
        else printf("\nstr_to_binw returned NULL");
        deallocate_1D_c(str);
    }
    else printf("\nstr_copy returned NULL");
}
